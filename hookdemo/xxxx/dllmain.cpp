// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "framework.h"
#include <stdio.h>

/*    ida 分析 exe 时显示的信息
.text:00401000 ;
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00401000 ; |           Copyright (c) 2014 Hex-Rays, <support@hex-rays.com>           |
.text:00401000 ; |                      License info: 48-3057-7374-2C                      |
.text:00401000 ; |     Zhou Tao, Jiangsu Australia Sinuo Network Technology Co., Ltd.      |
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ;
.text:00401000 ; Input MD5   : B294E8AD52E541CF989D738B60AF0752
.text:00401000 ; Input CRC32 : 994285A8
.text:00401000
.text:00401000 ; File Name   : C:\Users\ctwl\source\repos\hooktest\Release\hooktest.exe
.text:00401000 ; Format      : Portable executable for 80386 (PE)
.text:00401000 ; Imagebase   : 400000
.text:00401000 ; Section 1. (virtual address 00001000)
.text:00401000 ; Virtual size                  : 0000112D (   4397.)
.text:00401000 ; Section size in file          : 00001200 (   4608.)
.text:00401000 ; Offset to raw data for section: 00000400
.text:00401000 ; Flags 60000020: Text Executable Readable
.text:00401000 ; Alignment     : default
.text:00401000 ; PDB File Name : C:\Users\ctwl\source\repos\hooktest\Release\hooktest.pdb
.text:00401000
.text:00401000                 .686p
.text:00401000                 .mmx
.text:00401000                 .model flat
*/
////
#define  virtual_address 0x00001000    // 如上说明 Section 1. (virtual address 00001000)
#define  OUTPUT_FUNC_ADDR_OFFSET  (virtual_address + 0x80)     // ida 查找到的实际函数偏移地址

////  替换的函数
void dealHookFunc()
{
	printf("dealHookFunc succ \n");
}

/// shellcode的方式， 可以把  hookFunc 中的“dealHookFunc” 替换为 shellHookFunc
__declspec(naked) void shellHookFunc()
{
	__asm
	{
		jmp dealHookFunc;
		retn;
	}
}

static BYTE oldCode[32] = { 0 };   // 保存老的内容，后续还原
static int nsize = 0;
void hookFunc()
{
    DWORD baseAddress = (DWORD)GetModuleHandle(NULL);
    DWORD hookAddress = baseAddress + OUTPUT_FUNC_ADDR_OFFSET;

    //jmp 0x12345678
    //retn

    // 如上共6个字节
	BYTE hookCode[32] = { 0 };  
    hookCode[nsize++] = 0xE9; //   // 0xE9 0x12345678 : jmp  0x12345678    5个字节
	*(DWORD*)&hookCode[nsize++] = (DWORD)dealHookFunc - hookAddress - 5;  // 5个字节偏移 jmp call 都是相对地址
    nsize++;
    nsize++;
    nsize++;
    hookCode[nsize++] = 0xC3; // 0xC3 retn

	BOOL bRet = ReadProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, oldCode, nsize, 0);

    DWORD dwOldFlag, dwTempFlag;
    (void)VirtualProtect((void*)hookAddress, nsize, PAGE_READWRITE, &dwOldFlag);
    bRet = WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, hookCode, nsize, 0);
    (void)VirtualProtect((void*)hookAddress, nsize, dwOldFlag, &dwTempFlag);
}

void unHookFunc()
{
	if (oldCode[0] == 0) return;

	DWORD baseAddress = (DWORD)GetModuleHandle("hooktest.exe");

	DWORD hookAddress = baseAddress + OUTPUT_FUNC_ADDR_OFFSET;

    DWORD dwOldFlag, dwTempFlag;
    (void)VirtualProtect((void*)hookAddress, nsize, PAGE_READWRITE, &dwOldFlag);
	WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, oldCode, nsize, 0);
    (void)VirtualProtect((void*)hookAddress, nsize, dwOldFlag, &dwTempFlag);
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        printf("hook in \n");
        hookFunc();
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        printf("hook out \n");
        unHookFunc();
        break;
    }
    return TRUE;
}

